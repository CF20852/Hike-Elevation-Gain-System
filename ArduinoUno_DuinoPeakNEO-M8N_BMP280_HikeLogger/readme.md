This version is for the Arduino Uno with a shield containing a u-blox NEO-M8N, a Bosch BMP-280, and a microSD card socket.

If you buy a NEO-M8N/microSD shield from DuinoPeak, the NEO-M8N may come with firmware version 2.01.  If so, you may have to upgrade the firmware to version 3.01 for this configuration to work properly.  (Try it without upgrading the NEO-M8N firmware first.)  You can upgrade the firmware using the u-blox u-connect software, which I obtained from https://www.u-blox.com/en/evaluation-software-and-tools for my Windows 10 laptop.  Use the u-blox 8/M8 Firmware v 3.01 - ONLY for Standard Precision NGSS products, which I obtained at https://www.u-blox.com/sites/default/files/UBX_M8_301_SPG.911f2b77b649eb90f4be14ce56717b49.bin .

One of the benefits of upgrading is that you could configure the NEO-M8N to simultaneously use GPS, Galileo, and GLONASS or Galileo, GLONASS, and BeiDou signals.  See section 32.11.11 of the u-blox 8/ u-blox M8 Receiver Description Including Protocol Specification document (Document number UBX-13003221) to learn how to compose the necessary u-blox command.  I haven't included that in this sketch, due to the fact that running on an Arduino Uno, the sketch already consumes perilous amounts of flash and RAM.  The default configuration of the u-blox 8/u-blox M8 Standard Precision GNSS modules using both firmware versions 2.01 and 3.01 is to use GPS, SBAS, QZSS, and GLONASS signals.  See Appendix B.6, GNSS System Settings, of Document number UBX-13003221.  See Appendix A of that document for how u-blox numbers the GNSS system types 0-6, corresponding to GPS, SBAS, Galileo, BeiDou, IMES, QZSS, and GLONASS respectively.

In order to connect u-center running on my laptop to the NEO-M8N on the DuinoPeak shield, I used an Arduino Uno and configured the DuinoPeak shield to communicate with the Arduino Uno using D0 and D1, rather than D2 and D3.  I found trying to relay the serial port through the Arduino Uno software to be too unreliable.  I wrote a small sketch to configure D0 and D1 as inputs for this purpose, using the Arduino pinMode() function.